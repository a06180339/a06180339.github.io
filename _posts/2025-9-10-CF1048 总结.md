---
layout: post
title: "CF1048 总结"
date: 2025-9-10
tags: ["总结", "CF", "Div-2"]
comments: true
author: a06180339
---

A：
显然两个数最后都要变成它们的 lcm。

B：
前 m - n 秒显然没用，最后 n 秒贪心抢蛋糕即可。

C：
注意到操作一相当于  $x \to \frac{x}{2}$，操作二相当于 $x \to 2^k + \frac{x}{2}$。所以直接二进制分解一下就行。

D：
如果 $\exists i, b_i > b_{i + 1} > b_{i + 2}$ 则不行。

E1:
很有趣的一道题目。首先，答案一定小于等于深度最大的点的深度。
设其为 $c$。定义一层表示树上一些深度相等的点构成的集合
。那么我们如果要让所有叶子的 $lcs$ 最大的话，则对于树上深度小于等于 $c$ 的层，要尽量让一层里边的点的颜色一样。
所以如果存在一种选出一些层的方案，并且这些层的点数小于等于 k，并且这些层的点数加上深度大于 c 的点数小于等于 k 答案就是 c（就是说我们将选出来的层染白，深度大于 c 的点可以随便染色）。
否则答案就是 c - 1。所以我们可以用背包来判断有没有满足条件的选层的方案。

E2：
注意到背包太快了，我们需要优化一下背包。
解法 1：bitset
我们只用求能否凑出某个值。所以可以用 bitset 代替 DP 数组。
总复杂度是 $O(\frac{n^2}{\omega})$ 的。

解法 2：根号分治
我们是对每一层的点数进行背包。所以所有物品的重量的和是 n。那么我们就可以对重量进行根号分治。
如果重量大于根号，则这样的重量只会有根号种。如果重量小于根号，则我们将所有的重量相同的物品归为一类。
然后对于每一类，我们用二进制分组的方式，将每一类拆成 $\log n$ 个物品，进行背包。总复杂度是 $O(n \sqrt n)$ 的。
