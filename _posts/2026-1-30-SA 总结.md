---
layout: post
title: "SA 总结"
date: 2026-1-30
tags: ["字符串", "后缀数组", "7.1", "总结“]
comments: true
author: a06180339
---

已完成 SA 大学习。

SA，顾名思义，Suffix Array，就是后缀数组的意思。

我们先来考虑一个问题。给定一个字符串，多次询问，要我们求出两个后缀的 lcp（最长公共前缀）。

先将字符串的每一个后缀插入全部一颗 trie 树。可以发现询问就等价于询问两个后缀对应的点的 lca 的深度。（定以根的深度为 0）。

比如字符串 aba。我们构建出其每一个后缀构成的 trie，其中红色表示这个点代表长度为几的后缀。

![好吃的1](https://cdn.luogu.com.cn/upload/image_hosting/vhuhes6h.png)

（图画的太好看了，快来夸我）

那么，长为 3 的后缀与长为 1 的后缀的最长公共前缀，就是 $lca(2, 6)$ 的深度，即为 1。

但是，因为我们需要对每一个后缀都插入到 trie 里面，所以构建这个 trie 树的复杂度是 $O(n^2)$ 的，太慢了。怎么才能优化呢？

尝试优化建树过程。发现这个问题有点像虚树，在这个 trie 树上，真正用到的只有所有的叶子和叶子之间的 lca，所以有大量的点没用。我们考虑只记录叶子和他们之间 lca 的深度。

我们先在 trie 树上 dfs，每个点按照边权（连向另一个点的字母）从小到大的顺序来遍历。首先我们注意到我们如果先对字符串所有后缀排序，那么排序后后缀在 trie 上对应的点 dfn 序一定递增，因为 trie 树上每一个点的儿子是按照字符集的大小排序的，所以总会先遍历字典序小的字符，所以 trie 树上叶子的 dfn 的顺序就是后缀的字典序顺序。

那么，我们只需要对所有后缀按照字典序排序，就可以维护出叶子了。但是，我们对后缀排序的复杂度还是 $O(n^2)$ 的。又注意到一个后缀可以从中间被拆分成两端。那么我们可以倍增长度 len。定义 $tmp_i$ 表示上一轮的排序结果。每次我们就对 $[i, i + len]$ 排序，排序方法就是将二元组 $(tmp_i, tmp_{i + \frac{len}{2}})$ 按照第一维优先的顺序排序。然后一直倍增直到排序结束。

我们定义 $sa_i$ 表示排名为 $i$ 的后缀的起始位置。$rk_i$ 起始位置为 $i$ 的后缀的排名。sa 和 rk 互为逆映射。$end_i$ 表示排名为 i 的后缀在 trie 树上对应的点。

让我们回到原来的问题上。我们现在要求出两个点的 $lca$ 的深度。我们又注意到 $lca(end_i, end_j)$ 为 $\{lca(end_i, end_{i + 1}), lca(end_{i + 1}， end_{i + 2}), \cdots, lca(end_{j - 1}, end_{j})\}$ 这个集合中深度最小的点。那好办！我们可以求出区间深度最小的点，ST 表即可。

让我们先定义 $dep_i$ 表示 trie 树上点 i 的深度，$height_i$ 表示 $dep_{lca(end_{i}, end_{i + 1})}$。那么我们原问题转化为了每次给出 $l, r$，求 $\min_{i \le rk_r \land i \ge rk_l + 1} height_i$。

但是，$height_i$ 还是不好求。

我们仔细观察一下，可以发现有一个性质，就是 $height_{rk_i} \ge height_{rk_{i - 1}} - 1$。

![](https://cdn.luogu.com.cn/upload/image_hosting/a4ajyajt.png)

（这张图绝对是我画的）

注意到上一个式子相当于 i 开始的后缀的 height 一定大于等于 i - 1 开始的 height - 1。如上面那张图，i 开始的后缀就是 i - 1 开始的后缀删掉前面一个字符。那么 i 的前继后缀一定只比 i - 1 的前继后缀少一个最前面的字符。所以就有了上面那个性质。

那么，我们就可以根据前面那个性质递推求 height，复杂度分析一下就是 $O(n)$。

height 数组有很多有趣的性质。让我们来看几道例题。

1. [最小表示法](https://www.luogu.com.cn/problem/P13270)

   题意自己看吧。

:::success[Solution]
我们可以把这个字符串复制一遍，然后找到后缀字典序最小的一个，取前 n 个字符就是答案（显然字典序最小的一定至少有 n 个字符。）
:::

2. 两两 lcp

    

   题意：
   给一个长度为 $N$ 的字符串 $S$，令 $T_i$ 表示它从第 $i$ 个字符开始的后缀。求 $\sum_{1\le i<j\le N}{\{\mathrm{lcp}(T_i,T_j) \}}$ 其中，$\mathrm{len}(a)$ 表示 $a$ 的长度，$\mathrm{lcp}(a,b)$ 表示 $a$ 和 $b$ 的最长公共前缀

:::success[Soulution]
首先，这个东西等于 $\sum_{1\le l<r\le N} \min_{i \le r \land i \ge l + 1} height_i$。那么，我们用笛卡尔树，每个点的值为 $height_i$，按照值小的为父亲。这样最小值为 $height_i$ 的区间个数就是左边子树和右边子树大小的乘积。
:::

3. [优秀的拆分](https://www.luogu.com.cn/problem/P1117)

   题意：寻找字符串中 AABB 式的子串。

   :::success[Solution]
   AABB? 我们拆成求出以一个点结尾的 AA 的个数 f 和以一个点开始的 BB 串个数 g，则答案就是 $\sum_{i = 1}^n f_i g_{i + 1}$。

   首先我们有 $g$ 就是反串的 $f$。那么我们只考虑 $g$。首先，我们可以用哈希枚举 $i, j$，判断有没有从 i 开始的 AA 串来求 $f$。（这样为什么有 95？认真的吗？出题人真好）。考虑最后的 5 分。

   我们原本是枚举的点对。现在我们来考虑枚举 AA 串中 A 的长度 len，然后每 len 个点设一个关键点。这样，每个长度为 2len 的 AA 串至少经过 2 个关键点。

   那么我们就只考虑相邻的关键点，看看多少个 AA 串包含这两个关键点。假设这两个关键点分别为 $a, b$。

   我们先分类讨论一下。PS：lcs 就是反串的 lcp。

   1. $lcp(a, b) + lcs(a, b) < len$

      &#x20;稍微想想就可以发现这种情况无解。

   2. $lcp(a, b) + lcs(a, b) \ge len$

      ![](https://cdn.luogu.com.cn/upload/image_hosting/uz88kbhc.png)

      图中 a, b 表示相邻的两个关键点。然后红色表示 lcs，黄色表示 lcp。然后绿色表示红黄相交的部分。我们注意到从前面的绿色部分的任一点开始，一定存在分界点（AA 串中间的那个点) 在第二个绿色点的一个 AA 串。

      那么我们求出绿色部分，用线段树维护一下即可。
      求出 lcp，lcs 就用后缀数组。
   :::

5. [跳蚤](https://hydro.ac/p/bzoj-P4310)

   题意：把串分成不超过 $k$ 个子串，然后对于每个子串 $S$，从 $S$ 的所有子串中选择字典序最大的那一个，并在选出来的 $k$ 个子串中选择字典序最大的那一个。称其为“魔力串”。现在找一个最优的分法让“魔力串”字典序最小。输出魔力串即可。

   :::success[Solution]
   首先，预处理出后缀数组之类的东西。
   我们先尝试二分答案。但是，答案是个字符串二分不了。那怎么搞呢？

   我们尝试二分子串的排名来做。那么我们就先需要解决如何根据子串的排名求位置这个问题。这里，我们就需要用到一个结论，一个字符串的本质不同的子串个数等于 $\sum_{i = 1}^n n - sa_i - height_i$。$n - sa_i$ 就是后缀中字典序排名为 i 的后缀的长度。这个式子可以理解为，对 trie 树上每一个叶子节点的深度，减去 dfn 序最大的满足 dfn 序比当前叶子小的叶子与当前叶子 lca 的深度。这有点像建虚树，然后求出虚树点数的过程。

   那么我们求排名 k 对应的位置的话，就按照排名从小到大枚举后缀，然后比较排名与当前后缀的排名 i 的 $n - sa_i - height_i$ 的关系。如果排名大，那么排名减去 $n - sa_i - height_i$，继续枚举后缀。否则，字符串的开头，结尾就分别是 $sa_i, sa_i + height_i - 1 + k$。

   现在考虑如何写 check 函数。我们需要划分，然后让划分出的每一个子串都小于等于当前二分的子串。然后发现可以贪心。我们按照下标从大到小来划分。如果当前下标对应的字符大于二分的子串的第一个字符，那么显然没有合法划分方案。否则，我们找到上一个划分点。如果当前下标到上一个划分点这个字符串大于二分的字符串，那么必须得进行一次划分，从当前下标 +1（+1 因为不加不合法）到下一个划分点进行一次划分。最后判断划分的次数是否小于 k 即可。
   :::

6. [小猪猪与字符串](https://codeforces.com/problemset/problem/204/E)

   题意：给定 $n$ 个字符串，询问每个字符串有多少子串（不包括空串）是所有 $n$ 个字符串中至少 $k$ 个字符串的子串（注意包括本身）。

   :::success[Solution]
   额，在 k 个字符串中出现？SA 很不可做的样子。我们尝试枚举一个字符串的每一个后缀，求出以这个后缀的末尾结束的字符串的贡献。那么这个后缀带来的贡献，就是找到其他几个字符串中，后缀排名距离当前后缀最近的 k - 1 个（因为排名越近，lcp 越大）。然后这 k 个后缀（算上当前的) 的 lcp 就是这个后缀的贡献。

   先将所有的字符串合并在一起。我们对每一个字符串之间插入互不相同的分隔符，就可以合并所有的字符串，来求后缀数组了。

   我们现在先尝试求出所有的包含了至少 k 个字符串的极短区间（区间指 sa 数组的区间，极短指没有区间包含当前区间）。这个东西可以双指针乱搞。

   然后求出所有区间后，用线段树维护答案。对于每一个区间，将区间与这个区间所有后缀的 lcp 的长度取最大值。先对所有的区间按照 lcp 排序，就可以用普通线段树维护了。
   :::
